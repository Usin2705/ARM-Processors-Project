/*
===============================================================================
 Name        : main.c
 Author      : $(author)
 Version     :
 Copyright   : $(copyright)
 Description : main definition
===============================================================================
 */

#if defined (__USE_LPCOPEN)
#if defined(NO_BOARD_LIB)
#include "chip.h"
#else
#include "board.h"
#endif
#endif

#include <cr_section_macros.h>

// TODO: insert other include files here
#include "FreeRTOS.h"
#include "task.h"
#include "../inca/ITM_write.h"
#include <cstring>
#include "DigitalIoPin.h"

#include <mutex>
#include "../inca/Fmutex.h"

#include "stdio.h"
#include "../inca/user_vcom.h"
#include <map>


// TODO: insert other definitions and declarations here
volatile uint32_t RIT_count;
xSemaphoreHandle sbRIT = xSemaphoreCreateBinary();


/* the following is required if runtime statistics are to be collected */
extern "C" {

void vConfigureTimerForRunTimeStats( void ) {
	Chip_SCT_Init(LPC_SCTSMALL1);
	LPC_SCTSMALL1->CONFIG = SCT_CONFIG_32BIT_COUNTER;
	LPC_SCTSMALL1->CTRL_U = SCT_CTRL_PRE_L(255) | SCT_CTRL_CLRCTR_L; // set prescaler to 256 (255 + 1), and start timer
}
/* end runtime statictics collection */

void RIT_IRQHandler(void) {
	static DigitalIoPin btnStep(0,24, DigitalIoPin::output, true);

	// This used to check if a context switch is required
	portBASE_TYPE xHigherPriorityWoken = pdFALSE;
	// Tell timer that we have processed the interrupt.
	// Timer then removes the IRQ until next match occurs
	Chip_RIT_ClearIntStatus(LPC_RITIMER); // clear IRQ flag
	if(RIT_count > 0) {
		RIT_count--;
		btnStep.write(RIT_count%2==0);

	}
	else {
		Chip_RIT_Disable(LPC_RITIMER); // disable timer
		// Give semaphore and set context switch flag if a higher priority task was woken up
		xSemaphoreGiveFromISR(sbRIT, &xHigherPriorityWoken);
	}
	// End the ISR and (possibly) do a context switch
	portEND_SWITCHING_ISR(xHigherPriorityWoken);
}

}

void RIT_start(int count, int us)
{
	uint64_t cmp_value;
	// Determine approximate compare value based on clock rate and passed interval
	cmp_value = (uint64_t) Chip_Clock_GetSystemClockRate() * (uint64_t) us / 1000000;
	// disable timer during configuration
	Chip_RIT_Disable(LPC_RITIMER);
	RIT_count = count;
	// enable automatic clear on when compare value==timer value
	// this makes interrupts trigger periodically
	Chip_RIT_EnableCompClear(LPC_RITIMER);
	// reset the counter
	Chip_RIT_SetCounter(LPC_RITIMER, 0);
	Chip_RIT_SetCompareValue(LPC_RITIMER, cmp_value);
	// start counting
	Chip_RIT_Enable(LPC_RITIMER);
	// Enable the interrupt signal in NVIC (the interrupt controller)
	NVIC_EnableIRQ(RITIMER_IRQn);
	// wait for ISR to tell that we're done
	if(xSemaphoreTake(sbRIT, portMAX_DELAY) == pdTRUE) {
		// Disable the interrupt signal in NVIC (the interrupt controller)
		NVIC_DisableIRQ(RITIMER_IRQn);
	}
	else {
		// unexpected error
	}
}

/* Sets up system hardware */
static void prvSetupHardware(void)
{
	SystemCoreClockUpdate();
	Board_Init();

	/* Initial LED0 state is off */
	Board_LED_Set(0, false);

	ITM_init();

	// initialize RIT (= enable clocking etc.)
	Chip_RIT_Init(LPC_RITIMER);
	// set the priority level of the interrupt
	// The level must be equal or lower than the maximum priority specified in FreeRTOS config
	// Note that in a Cortex-M3 a higher number indicates lower interrupt priority
	NVIC_SetPriority( RITIMER_IRQn, configMAX_SYSCALL_INTERRUPT_PRIORITY + 1);
}

struct Color {
	uint8_t red;
	uint8_t blue;
	uint8_t green;
};


void PWM_set(uint8_t val) // set PWM duty cycle (from 0 to 100%)
{
	//should we inverse here. INSTRUCTION SAY NOTHING ABOUT THIS.
	LPC_SCT0->MATCHREL[1].L = val;
}

long map(long x, long in_min, long in_max, long out_min, long out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

/* send data and toggle thread */
static void led_task(void *xSemaphore) {
	USB_send((uint8_t *)"USB putty running. Program started \r\n", strlen("USB putty running. Program started \r\n"));
	char buffer[RCV_BUFSIZE];
	Color color = {0,0,0};
	int hex = 0;
	char myChar[11] = {0};
	char myBuffer[60] = {'\0'};
	uint8_t index = 0;
	bool isCommand = false;

	while (1) {
		uint32_t len = USB_receive((uint8_t *) buffer, RCV_BUFSIZE);
		buffer[len] = 0;
		USB_send((uint8_t *) buffer, len);

		for (uint8_t i = 0; i < len; i++){
			myChar[index] = buffer[i];
			index++;

			if ((index == 11) || (buffer[i] == '\r')) {
				USB_send((uint8_t *) "\r\n", 2);
				index = 0;
				isCommand = true;
			}
		}

		if (isCommand) {
			if(myChar[0] == 'r' && myChar[1] == 'g' && myChar[2] == 'b' && myChar[3] == ' ' && myChar[4] == '#') {
				sscanf(myChar, "rgb #%x", &hex);
				color.red = hex >> 16;
				color.green = (hex&0xff00) >> 8;
				color.blue = hex&0xff;
				sprintf(myBuffer, "Red %x Green %x Blue %x \r\n", color.red, color.green, color.blue);
				USB_send((uint8_t *) myBuffer, 60);

				LPC_SCTLARGE0->MATCHREL[1].L = map(color.red, 255, 0, 0, 1000);
				LPC_SCTLARGE0->MATCHREL[1].H = map(color.green, 255, 0, 0, 1000);
				LPC_SCTLARGE1->MATCHREL[1].L = map(color.blue, 255, 0, 0, 1000);

			} else {
				USB_send((uint8_t *) "Ugh! Wrong command!\r\n", strlen("Ugh! Wrong command!\r\n"));
			}

			isCommand = false;
			memset(myChar, '\0', 11);
		}

	}
}



static void SCT_Init(){
	Chip_SCT_Init(LPC_SCTLARGE0);
	Chip_SCT_Init(LPC_SCTLARGE1);

	Chip_SWM_MovablePortPinAssign(SWM_SCT0_OUT0_O, 0,25); // Red
	Chip_SWM_MovablePortPinAssign(SWM_SCT0_OUT1_O, 0,3); // Green
	Chip_SWM_MovablePortPinAssign(SWM_SCT1_OUT0_O, 1,1); // Blue

	LPC_SCTLARGE0->CONFIG |= (1 << 17); // two 16-bit timers, auto limit
	LPC_SCTLARGE0->CONFIG |= (1 << 18); // two 16-bit timers, auto limit, high timer
	LPC_SCTLARGE0->CTRL_L |= (72-1) << 5; // set prescaler, SCTimer/PWM clock = 1 MHz
	LPC_SCTLARGE0->CTRL_H |= (72-1) << 21; // set prescaler, SCTimer/PWM clock = 1 MHz, HIgh

	LPC_SCTLARGE0->MATCHREL[0].L = 1000-1; // match 0 @ 10/1MHz = 10 usec (100 kHz PWM freq) (1MHz/1000)
	LPC_SCTLARGE0->MATCHREL[1].L = 950; // match 1 used for duty cycle (in 10 steps)

	LPC_SCTLARGE0->MATCHREL[0].H = 1000-1; // match 0 @ 10/1MHz = 10 usec (100 kHz PWM freq) (1MHz/1000)
	LPC_SCTLARGE0->MATCHREL[1].H = 950; // match 1 used for duty cycle (in 10 steps)

	LPC_SCTLARGE0->EVENT[0].STATE = 0xFFFFFFFF; // event 0 happens in all states
	LPC_SCTLARGE0->EVENT[0].CTRL = (1 << 12); // match 0 condition only

	LPC_SCTLARGE0->EVENT[1].STATE = 0xFFFFFFFF; // event 1 happens in all states
	LPC_SCTLARGE0->EVENT[1].CTRL = (1 << 0) | (1 << 12); // match 1 condition only

	LPC_SCTLARGE0->EVENT[2].STATE = 0xFFFFFFFF; // event 0 happens in all states
	LPC_SCTLARGE0->EVENT[2].CTRL = (1 << 12) | (1 << 4); // match 0 condition only High event

	LPC_SCTLARGE0->EVENT[3].STATE = 0xFFFFFFFF; // event 2 happens in all states
	LPC_SCTLARGE0->EVENT[3].CTRL = (1 << 0) | (1 << 12) | (1 << 4); // match 2 condition only High event

	LPC_SCTLARGE0->OUT[0].SET = (1 << 0); // event 0 will set SCTx_OUT0
	LPC_SCTLARGE0->OUT[0].CLR = (1 << 1); // event 1 will clear SCTx_OUT0

	LPC_SCTLARGE0->OUT[1].SET = (1 << 2); // event 0 will set SCTx_OUT1
	LPC_SCTLARGE0->OUT[1].CLR = (1 << 3); // event 2 will clear SCTx_OUT1

	LPC_SCTLARGE0->CTRL_L &= ~(1 << 2); // unhalt it by clearing bit 2 of CTRL reg
	LPC_SCTLARGE0->CTRL_H &= ~(1 << 2); // unhalt it by clearing bit 2 of CTRL reg

	//LPC_SCRLARGE1
	LPC_SCTLARGE1->CONFIG |= (1 << 17); // two 16-bit timers, auto limit

	LPC_SCTLARGE1->CTRL_L |= (72-1) << 5; // set prescaler, SCTimer/PWM clock = 1 MHz

	LPC_SCTLARGE1->MATCHREL[0].L = 1000-1; // match 0 @ 10/1MHz = 10 usec (100 kHz PWM freq) (1MHz/1000)
	LPC_SCTLARGE1->MATCHREL[1].L = 950; // match 1 used for duty cycle (in 10 steps)
	LPC_SCTLARGE1->EVENT[0].STATE = 0xFFFFFFFF; // event 0 happens in all states
	LPC_SCTLARGE1->EVENT[0].CTRL = (1 << 12); // match 0 condition only
	LPC_SCTLARGE1->EVENT[1].STATE = 0xFFFFFFFF; // event 1 happens in all states
	LPC_SCTLARGE1->EVENT[1].CTRL = (1 << 0) | (1 << 12); // match 1 condition only
	LPC_SCTLARGE1->OUT[0].SET = (1 << 0); // event 0 will set SCTx_OUT0
	LPC_SCTLARGE1->OUT[0].CLR = (1 << 1); // event 1 will clear SCTx_OUT0
	LPC_SCTLARGE1->CTRL_L &= ~(1 << 2); // unhalt it by clearing bit 2 of CTRL reg
}

int main(void) {

	prvSetupHardware();
	SCT_Init();

	/* LED1 toggle thread */
	xTaskCreate(led_task, "led",
			configMINIMAL_STACK_SIZE*2, NULL, (tskIDLE_PRIORITY + 1UL),
			(TaskHandle_t *) NULL);

	xTaskCreate(cdc_task, "CDC",
			300, NULL, (tskIDLE_PRIORITY + 1UL),
			(TaskHandle_t *) NULL);

	/* Start the scheduler */
	vTaskStartScheduler();

	/* Should never arrive here */
	return 1;
}
